#version 460
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#define TRI_LIGHT_BUFFER_BINDING 0
#define VERTEX_BUFFER_BINDING 1
#define INDEX_BUFFER_BINDING 2
#define SCENE_DATA_BUFFER_BINDING 3
#define TEXTURE_ARRAY_BINDING 4
#include "scene.glsl"

layout(local_size_x = 256) in;

layout(push_constant, scalar) uniform push_constant_buffer
{
    uint triangle_count;
    uint instance_id;
} control;

void main()
{
    uint input_index = gl_GlobalInvocationID.x;
    if(input_index < control.triangle_count)
    {
        instance o = scene.o[control.instance_id];

        uint output_index = o.light_base_id + gl_GlobalInvocationID.x;
        tri_light light;
        light.emission_tex_id = o.mat.emission_tex_id;
        light.emission_factor = o.mat.emission_factor_double_sided.rgb;

        ivec3 i = ivec3(
            indices[nonuniformEXT(control.instance_id)].i[3*input_index+0],
            indices[nonuniformEXT(control.instance_id)].i[3*input_index+1],
            indices[nonuniformEXT(control.instance_id)].i[3*input_index+2]
        );
        vertex v0 = vertices[nonuniformEXT(control.instance_id)].v[i.x];
        vertex v1 = vertices[nonuniformEXT(control.instance_id)].v[i.y];
        vertex v2 = vertices[nonuniformEXT(control.instance_id)].v[i.z];
#ifdef PRE_TRANSFORMED_VERTICES
        light.pos[0] = v0.pos;
        light.pos[1] = v1.pos;
        light.pos[2] = v2.pos;
#else
        light.pos[0] = (o.model * vec4(v0.pos, 1)).xyz;
        light.pos[1] = (o.model * vec4(v1.pos, 1)).xyz;
        light.pos[2] = (o.model * vec4(v2.pos, 1)).xyz;
#endif
        light.uv[0] = v0.uv;
        light.uv[1] = v1.uv;
        light.uv[2] = v2.uv;

        vec3 emission = light.emission_factor;
        if(light.emission_tex_id >= 0)
        {
            vec2 uv = (v0.uv + v1.uv + v2.uv) / 3.0f;
            vec2 grad = max(abs(v0.uv - uv), max(abs(v1.uv - uv), abs(v2.uv - uv)));
            emission *= textureGrad(textures[nonuniformEXT(light.emission_tex_id)], uv, grad, grad).rgb;
        }
        light.power_estimate = rgb_to_luminance(emission) * triangle_surface_area(light.pos[0], light.pos[1], light.pos[2]);

        if(o.mat.emission_factor_double_sided.a > 0.5f)
            light.power_estimate = -light.power_estimate;

        tri_lights.lights[output_index] = light;
    }
}

