#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable

#include "svgf.glsl"
#include "gbuffer.glsl"
#include "random_sampler.glsl"
#include "math.glsl"
#include "scene.glsl"

layout(binding = 0, set = 0, rgba32f) uniform readonly image2DArray in_diffuse;
layout(binding = 1, set = 0, rgba32f) uniform readonly image2DArray normal;
layout(binding = 2, set = 0) uniform sampler2DArray in_depth;
layout(binding = 3, set = 0, rgba32f) uniform image2DArray out_diffuse;
layout(binding = 4) buffer uniforms
{
    uint frame_index;
} uniforms_buffer;
layout(binding = 5, set = 0, rgba32f) uniform readonly image2DArray in_specular;
layout(binding = 6, set = 0, rgba32f) uniform image2DArray out_specular;
layout(binding = 7, set = 0, rgba32f) uniform image2DArray in_material;


const vec3 poisson_disk[8] = {
    // https://www.desmos.com/calculator/abaqyvswem
    vec3( -1.00             ,  0.00             , 1.0 ),
    vec3(  0.00             ,  1.00             , 1.0 ),
    vec3(  1.00             ,  0.00             , 1.0 ),
    vec3(  0.00             , -1.00             , 1.0 ),
    vec3( -0.25 * sqrt(2.0) ,  0.25 * sqrt(2.0) , 0.5 ),
    vec3(  0.25 * sqrt(2.0) ,  0.25 * sqrt(2.0) , 0.5 ),
    vec3(  0.25 * sqrt(2.0) , -0.25 * sqrt(2.0) , 0.5 ),
    vec3( -0.25 * sqrt(2.0) , -0.25 * sqrt(2.0) , 0.5 )
};

layout (local_size_x = 16, local_size_y = 16) in;
void main()
{
    const ivec3 p = ivec3(gl_GlobalInvocationID.xyz);
    if (!all(lessThan(p.xy, control.size))) return;

    float diffuse_blur_radius = PREPASS_DIFFUSE_BLUR_RADIUS;

    camera_data curr_camera = camera.pairs[p.z].current;

    vec3 view_pos;
    {
        bool invalid = get_view_pos(in_depth, p, curr_camera, view_pos);
        if (invalid) return;
    }
    const float Z = abs(view_pos.z);
    const float frustum_size = control.min_rect_dim_mul_unproject * Z;
    const float inv_dist_to_point = 1.0 / frustum_size;

    vec4 color = imageLoad(in_diffuse, p);

    float hit_dist = color.a != 0.0 ? 1.0 / color.a : 1.0;
    hit_dist = 1.0;
    diffuse_blur_radius *= saturate(hit_dist * inv_dist_to_point);
    diffuse_blur_radius = max(diffuse_blur_radius, 1.0);

    const float plane_dist_sensitivity = 0.005;
    const float plane_dist_scale = inv_dist_to_point / plane_dist_sensitivity;

    const float diff_half_angle = get_specular_lobe_half_angle(0.75, 1.0);

    vec3 center_pos;
    {
        bool invalid = get_pos(in_depth, p, curr_camera, center_pos);
        if (invalid) return;
    }
    vec3 center_normal = unpack_gbuffer_normal(imageLoad(normal, p).xy);

    float w_sum = 1.0;

    random_sampler rs = init_random_sampler(uvec4(p, uniforms_buffer.frame_index));
    vec4 r = generate_uniform_random(rs);
    float theta = r.x * 2.0 * M_PI;
    float cx = cos(theta);
    float sx = sin(theta);
    mat2 rot = mat2(cx, sx, -sx, cx);
    //rot = mat2(1.0);

#if PREPASS_ENABLED == 1
    for (int i = 0; i < 8; ++i)
    {
        ivec3 q = ivec3(p.xy + rot * poisson_disk[i].xy * diffuse_blur_radius, p.z);

        if (!is_in_screen(q.xy)) continue;

        vec3 X;
        {
            bool invalid = get_pos(in_depth, q, curr_camera, X);
            if (invalid) continue;
        }

        vec4 c = imageLoad(in_diffuse, q);

        float plane_dist = abs(dot((X - center_pos), center_normal) * plane_dist_scale);
        float plane_dist_weight = step(plane_dist, 1);

        vec3 Ns = unpack_gbuffer_normal(imageLoad(normal, q).rg);
        float ndotn = saturate(dot(Ns, center_normal));
        float angle = acos(ndotn);
        float angle_percentage = angle / diff_half_angle;
        float normal_weight = exp(-3.0 * angle_percentage);

        float r = poisson_disk[i].z;
        float gaussian_weight = exp( -0.66 * r * r );

        float w = 1.0;
        w *= plane_dist_weight;
        w *= normal_weight;
        w *= gaussian_weight;

        color += c * w;
        w_sum += w;
    }

    color /= w_sum;
    //color.xyz = vec3(r.x);
#endif

    float specular_blur_radius = PREPASS_SPECULAR_BLUR_RADIUS;
    specular_blur_radius *= inv_dist_to_point;
    specular_blur_radius = max(specular_blur_radius, 1.0);
    vec2 metallic_roughness = imageLoad(in_material, p).rg;
    const float spec_half_angle = get_specular_lobe_half_angle(0.5, metallic_roughness.g);
    vec4 specular = imageLoad(in_specular, p);
    w_sum = 1.0;
    float max_inv_hit_dist = specular.a;

    vec3 camera_pos = camera.pairs[p.z].current.origin.xyz;
    vec3 V = normalize(camera_pos - center_pos);
#if PREPASS_ENABLED == 1
    for (int i = 0; i < 8; ++i)
    {
        ivec3 q = ivec3(p.xy + rot * poisson_disk[i].xy * specular_blur_radius, p.z);

        if (!is_in_screen(q.xy)) continue;

        vec3 X;
        {
            bool invalid = get_pos(in_depth, q, curr_camera, X);
            if (invalid) continue;
        }

        vec4 c = imageLoad(in_specular, q);

        float plane_dist = abs(dot((X - center_pos), center_normal) * plane_dist_scale);
        float plane_dist_weight = step(plane_dist, 1);

        vec3 Ns = unpack_gbuffer_normal(imageLoad(normal, q).rg);
        float ndotn = saturate(dot(Ns, center_normal));
        float angle = acos(ndotn);
        float angle_percentage = angle / spec_half_angle;
        float normal_weight = exp(-3.0 * angle_percentage);

        vec3 Vs = normalize(camera_pos - X);
        float Rs = imageLoad(in_material, q).g;

        float lobe_similarity = specular_lobe_similarity(V, center_normal, metallic_roughness.g, Vs, Ns, Rs);
        float lobe_weight = pow(lobe_similarity, 16.0);

        float r = poisson_disk[i].z;
        float gaussian_weight = exp( -0.66 * r * r );

        float w = 1.0;
        w *= plane_dist_weight;
        //w *= normal_weight;
        w *= lobe_weight;
        w *= gaussian_weight;

        if (w > 1e-4)
        {
            specular += c * w;
            w_sum += w;
            max_inv_hit_dist = max(max_inv_hit_dist, c.a);
        }
    }

    specular /= w_sum;
#endif

    imageStore(out_specular, p, vec4(specular.rgb, max_inv_hit_dist));
    imageStore(out_diffuse, p, color);
}